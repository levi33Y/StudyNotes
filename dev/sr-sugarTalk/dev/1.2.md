等候室、锁定会议，ui



## 会议时间长出现杂音问题



在控制台-Memory-录制一段时间内，观察到Constructor AudioContext 类不断增加，判断是逻辑问题导致内存泄漏



确保new AudioContext 唯一



使用audioContex的音量频率计算方法

~~~ts
//this.audioContextAnalysis audioContext 变量

private setFrequency(stream:MediaStream) {
  if (this.audioContextAnalysis) {
    this.cleanupAudioResources(this.audioContextAnalysis);
  }

  if (!stream) {
    return;
  }

  const context = new AudioContext();

  this.audioContextAnalysis = context;

  let source: MediaStreamAudioSourceNode | undefined;

  let analyser: AnalyserNode | undefined;

  try {
    source = context.createMediaStreamSource(stream);

    analyser = context.createAnalyser();

    source.connect(analyser);

    analyser.fftSize = 256;

    const frequencyBinCount = analyser.frequencyBinCount;

    const dataArray = new Uint8Array(frequencyBinCount);

    const loop = () => {
      if (!this.audioContextAnalysis || !source || !analyser) {
        this.audioContextAnalysis &&
          this.cleanupAudioResources(
            this.audioContextAnalysis,
            source,
            analyser,
          );

        return;
      }

      analyser?.getByteFrequencyData(dataArray);

      const totalFrequency = dataArray.reduce((sum, value) => sum + value, 0);

      this.frequency = totalFrequency / frequencyBinCount;

      requestAnimationFrame(loop);
    };

    loop();
  } catch (error) {
    this.cleanupAudioResources(context, source, analyser);
  }
}

private cleanupAudioResources(
  context?: AudioContext | null,
  source?: MediaStreamAudioSourceNode,
  analyser?: AnalyserNode,
) {
  if (!context) return;

  try {
    if (source) {
      source.disconnect();
    }
    if (analyser) {
      analyser.disconnect();
    }
    context.close().catch(console.error);
  } finally {
    this.audioContextAnalysis = null;
  }
}
~~~


