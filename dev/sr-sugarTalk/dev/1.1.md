## livekit扬声器和麦克风切换问题

操作本地参会人，删除和添加新轨道

stop方法会摧毁资源

=>

本地room对象切换设备



## 客户端-设置-关于我们

### ui

### 导出文件

~~~ts

import { ElMessage } from "element-plus";
import * as XLSX from "xlsx";

export const exportByExcel = (
  tableData: string[][] = [],
  filename?: string
) => {
  try {
    const sheet = XLSX.utils.aoa_to_sheet(tableData);

    let bookNew = XLSX.utils.book_new();

    XLSX.utils.book_append_sheet(bookNew, sheet, filename ?? "document");

    XLSX.writeFile(bookNew, (filename ?? "document") + ".xlsx");
  } catch (err) {
    ElMessage.error("導出失敗");
  }
};
~~~



## 录制-查看录制

### ui

### electron导出文件

### 导出word

```
# 插件库
PizZip
file-saver
docxtemplater

# result docx template
{#list}{content}

{/list}

# summary docx template
會議摘要
{#result}
{title}
{content}
{/result}

會議待辦
{#summary}
{todo}
{/summary}
```

~~~ts
  const onExport = debounce((value: any[] = []) => {
    const _exportByWord = async (
      data: string[] | ISummaryTextProps,
      type?: "result" | "summary",
    ) => {
      let templateDoc: string = "",
        docData;

      try {
        
        // 不同模版模版数据结构
        if (type === "result") {
          templateDoc = "result.docx";

          docData = {
            list: (data as string[]).map((item) => ({
              content: item,
            })),
          };
        } else if (type == "summary") {
          templateDoc = "summary.docx";

          const summaryData = data as ISummaryTextProps;
      
          docData = {
            result: summaryData.abstract.map((item) => ({
              title: item?.abstractTitle ?? "",
              content: item?.abstractContent ?? "",
            })),
            summary: summaryData.meetingTodoItems.map((item) => ({
              todo: item ?? "",
            })),
          };
        }

        if (!templateDoc || !docData) {
          throw new Error("templateDoc is not defined");
        }

        // 获取模版
        const response = await fetch(templateDoc);

        const blob = await response.blob();

        const arrayBuffer = await blob.arrayBuffer();

        const zip = new PizZip(arrayBuffer);

        const doc = new Docxtemplater().loadZip(zip);

        doc.setOptions({
          nullGetter: function () {
            return "";
          },
        });

        doc.setData(docData);

        doc.render();

        const out = doc.getZip().generate({
          type: "blob",
          mimeType:
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        });

        saveAs(out, `${state.title}.docx`);
      } catch (e) {
        ElMessage({
          message: "導出失敗",
          type: "error",
        });
      }
    };
~~~



### 导出pdf

~~~
# 插件
jsPDF

# 语言，下载静态语言包
sourcehansansk.ts

~~~



~~~ts
const _exportByPdf = (
      data: string[] | ISummaryTextProps,
      type: "result" | "summary",
    ) => {
      const doc = new jsPDF({
        orientation: "p",
        unit: "mm",
        format: "a4",
      });

			// 添加字体      
      doc.addFileToVFS("extend", sourcehansansk);

      doc.addFont("extend", "ex", "normal");

      doc.setFont("ex");

      const startX = 10,
        startY = 10,
        lineHeight = 10;

      const pageWidth = doc.internal.pageSize.getWidth() - startX * 2;

      const pageHeight = doc.internal.pageSize.getHeight();

      let nowY = startY;

      try {
        // 模版一
        if (type === "result") {
          const resultData = (data as string[]).join("\n");

          const lines = doc.splitTextToSize(resultData, pageWidth, {
            wordwrap: true,
          });

          lines.forEach((line: string, index: number) => {
            if (nowY > pageHeight) {
              doc.addPage();

              nowY = startY;
            }

            doc.text(line, startX, nowY);

            nowY += lineHeight;
          });
        }
        //模版二
        else if (type == "summary") {
          const summaryTextData = data as ISummaryTextProps;

          const titleTopics = "會議摘要";

          doc.setFontSize(20);

          doc.text(titleTopics, startX, nowY);

          nowY += lineHeight * 2;

          doc.setFontSize(16);

          summaryTextData.abstract?.forEach((topic) => {
            if (nowY > pageHeight) {
              doc.addPage();

              nowY = startY;
            }

            const topicTitle = topic?.abstractTitle ?? "";

            const topicDescription = topic?.abstractContent ?? "";

            doc.text(topicTitle, startX, nowY);

            nowY += lineHeight;

            const lines = doc.splitTextToSize(topicDescription, pageWidth, {
              wordwrap: true,
            });

            lines.forEach((line: string) => {
              doc.text(line, startX, nowY);
              nowY += lineHeight;
            });

            nowY += lineHeight;
          });

          const titleActionItems = "會議待辦";

          doc.setFontSize(20);

          doc.text(titleActionItems, startX, nowY);

          nowY += lineHeight * 2;

          doc.setFontSize(16);

          summaryTextData.meetingTodoItems?.forEach((actionItem) => {
            if (nowY > pageHeight) {
              doc.addPage();

              nowY = startY;
            }
            const formattedActionItem = `• ${actionItem ?? ""}`;

            const lines = doc.splitTextToSize(formattedActionItem, pageWidth, {
              wordwrap: true,
            });

            lines.forEach((line: string) => {
              doc.text(line, startX, nowY);

              nowY += lineHeight;
            });

            nowY += lineHeight;
          });
        }

        
        doc.save(`${state.title}.pdf`);
      } catch (err) {
        ElMessage({
          message: "導出失敗",
          type: "error",
        });
      }
    };
~~~



### elctron导出视频

~~~ts
//渲染进程
downloadVideo: (url: string | string[]) => {
  return ipcRenderer.invoke("download-video", url);
},
//主进程
ipcMain.handle("download-video", async (_, urls: string[] | string) => {
  const win = BrowserWindow.getFocusedWindow();

  const list = Array.isArray(urls) ? urls : [urls];

  const downloadDirectory =
    recordSavePath ||
    path.join(app.getPath("downloads"), "SugarTalk_Downloads");

  if (!fs.existsSync(downloadDirectory)) {
    fs.mkdirSync(downloadDirectory, { recursive: true });
  }

  const succeeded: string[] = [];

  const failed: { url: string; error: string }[] = [];

  for (const url of list) {
    try {
      const item = await download(win!, url, {
        directory: downloadDirectory,
        saveAs: false,
      });

      const savePath =
        typeof item?.getSavePath === "function" ? item.getSavePath() : "";

      succeeded.push(savePath || url);
    } catch (e) {
      failed.push({ url, error: (e as Error).message });
    }
  }

  return {
    success: failed.length === 0,
    directory: downloadDirectory,
    succeeded,
    failed,
  };
});
~~~

### video 元素



## 管理成员

ui

### 鉴权

计算属性+枚举，条件渲染显示按钮

#### 动态ref 列表渲染完成鼠标聚焦操作按钮条件渲染

~~~ts
// 列表渲染要key属性唯一（id），保证重新渲染

const optionUserRefs = ref<HTMLDivElement[]>([]);

optionUserRefs.value?.at(index)?.style &&
    (optionUserRefs.value.at(index)!.style.display = "flex");


:ref="
  (el) => {
    optionUserRefs[index] = el as HTMLDivElement;
  }
"
~~~



## 预定会议和列表

ui

懒加载和动态ref

### electron窗口通信

MessageChannel模块

* 通信地址，因为electron每个窗口不同，所以要明确url，否者使用0.0.0.0广播

~~~ts
//preload
window.channelMessaging = {
  // 发送消息
  onSendMessage: (message) => {
    return ipcRenderer.invoke("channel-send-message", message);
  },
  //订阅消息
  onGiveMessage: () => {
    ipcRenderer.on("main-give-message", async (e) => {
      const origin = process.env.VITE_DEV_SERVER_URL + "";
      window.postMessage("main-give-message", "*", e.ports);
    });
  },
}
  
// mian
ipcMain.handle("channel-send-message", async (_, message: any) => {
  const targetWin = BrowserWindow.getFocusedWindow().getParentWindow();

  if (!targetWin) return;

  const { port1, port2 } = new MessageChannelMain();

  port2.postMessage(message);

  port2.close();

  targetWin.webContents.postMessage("main-give-message", null, [port1]);
});

ipcMain.handle("close-window-focus", async (_, path?: string) => {
  if (path) {
    const windowItem = windowManage.get(path);
    if (windowItem?.id) {
      BrowserWindow.fromId(windowItem.id).close();
    }
  } else {
    BrowserWindow.getFocusedWindow().close();
  }
});
~~~

~~~ts

//give
window.channelMessaging.onGiveMessage();

window.onmessage = (e) => {
  if (e.data === "main-give-message") {
    const [port] = e.ports;

    port.onmessage = (e) => {
      handleUpdateChannelMessage(e?.data);
    };
  }

  state.isModel = false;
};
~~~



主进程-渲染进程监听



### electron父子窗口