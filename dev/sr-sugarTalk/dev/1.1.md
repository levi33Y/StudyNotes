## livekit扬声器和麦克风切换问题

操作本地参会人，删除和添加新轨道

stop方法会摧毁资源

=>

本地room对象切换设备



## 客户端-设置-关于我们

### ui

### 导出文件

~~~ts

import { ElMessage } from "element-plus";
import * as XLSX from "xlsx";

export const exportByExcel = (
  tableData: string[][] = [],
  filename?: string
) => {
  try {
    const sheet = XLSX.utils.aoa_to_sheet(tableData);

    let bookNew = XLSX.utils.book_new();

    XLSX.utils.book_append_sheet(bookNew, sheet, filename ?? "document");

    XLSX.writeFile(bookNew, (filename ?? "document") + ".xlsx");
  } catch (err) {
    ElMessage.error("導出失敗");
  }
};
~~~



## 录制-查看录制

### ui

### electron导出文件

### 导出word

```
# 插件库
PizZip
file-saver
docxtemplater

# result docx template
{#list}{content}

{/list}

# summary docx template
會議摘要
{#result}
{title}
{content}
{/result}

會議待辦
{#summary}
{todo}
{/summary}
```

~~~ts
  const onExport = debounce((value: any[] = []) => {
    const _exportByWord = async (
      data: string[] | ISummaryTextProps,
      type?: "result" | "summary",
    ) => {
      let templateDoc: string = "",
        docData;

      try {
        
        // 不同模版模版数据结构
        if (type === "result") {
          templateDoc = "result.docx";

          docData = {
            list: (data as string[]).map((item) => ({
              content: item,
            })),
          };
        } else if (type == "summary") {
          templateDoc = "summary.docx";

          const summaryData = data as ISummaryTextProps;
      
          docData = {
            result: summaryData.abstract.map((item) => ({
              title: item?.abstractTitle ?? "",
              content: item?.abstractContent ?? "",
            })),
            summary: summaryData.meetingTodoItems.map((item) => ({
              todo: item ?? "",
            })),
          };
        }

        if (!templateDoc || !docData) {
          throw new Error("templateDoc is not defined");
        }

        // 获取模版
        const response = await fetch(templateDoc);

        const blob = await response.blob();

        const arrayBuffer = await blob.arrayBuffer();

        const zip = new PizZip(arrayBuffer);

        const doc = new Docxtemplater().loadZip(zip);

        doc.setOptions({
          nullGetter: function () {
            return "";
          },
        });

        doc.setData(docData);

        doc.render();

        const out = doc.getZip().generate({
          type: "blob",
          mimeType:
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        });

        saveAs(out, `${state.title}.docx`);
      } catch (e) {
        ElMessage({
          message: "導出失敗",
          type: "error",
        });
      }
    };
~~~



### 导出pdf

~~~
# 插件
jsPDF

# 语言，下载静态语言包
sourcehansansk.ts

~~~



~~~ts
const _exportByPdf = (
      data: string[] | ISummaryTextProps,
      type: "result" | "summary",
    ) => {
      const doc = new jsPDF({
        orientation: "p",
        unit: "mm",
        format: "a4",
      });

			// 添加字体      
      doc.addFileToVFS("extend", sourcehansansk);

      doc.addFont("extend", "ex", "normal");

      doc.setFont("ex");

      const startX = 10,
        startY = 10,
        lineHeight = 10;

      const pageWidth = doc.internal.pageSize.getWidth() - startX * 2;

      const pageHeight = doc.internal.pageSize.getHeight();

      let nowY = startY;

      try {
        // 模版一
        if (type === "result") {
          const resultData = (data as string[]).join("\n");

          const lines = doc.splitTextToSize(resultData, pageWidth, {
            wordwrap: true,
          });

          lines.forEach((line: string, index: number) => {
            if (nowY > pageHeight) {
              doc.addPage();

              nowY = startY;
            }

            doc.text(line, startX, nowY);

            nowY += lineHeight;
          });
        }
        //模版二
        else if (type == "summary") {
          const summaryTextData = data as ISummaryTextProps;

          const titleTopics = "會議摘要";

          doc.setFontSize(20);

          doc.text(titleTopics, startX, nowY);

          nowY += lineHeight * 2;

          doc.setFontSize(16);

          summaryTextData.abstract?.forEach((topic) => {
            if (nowY > pageHeight) {
              doc.addPage();

              nowY = startY;
            }

            const topicTitle = topic?.abstractTitle ?? "";

            const topicDescription = topic?.abstractContent ?? "";

            doc.text(topicTitle, startX, nowY);

            nowY += lineHeight;

            const lines = doc.splitTextToSize(topicDescription, pageWidth, {
              wordwrap: true,
            });

            lines.forEach((line: string) => {
              doc.text(line, startX, nowY);
              nowY += lineHeight;
            });

            nowY += lineHeight;
          });

          const titleActionItems = "會議待辦";

          doc.setFontSize(20);

          doc.text(titleActionItems, startX, nowY);

          nowY += lineHeight * 2;

          doc.setFontSize(16);

          summaryTextData.meetingTodoItems?.forEach((actionItem) => {
            if (nowY > pageHeight) {
              doc.addPage();

              nowY = startY;
            }
            const formattedActionItem = `• ${actionItem ?? ""}`;

            const lines = doc.splitTextToSize(formattedActionItem, pageWidth, {
              wordwrap: true,
            });

            lines.forEach((line: string) => {
              doc.text(line, startX, nowY);

              nowY += lineHeight;
            });

            nowY += lineHeight;
          });
        }

        
        doc.save(`${state.title}.pdf`);
      } catch (err) {
        ElMessage({
          message: "導出失敗",
          type: "error",
        });
      }
    };
~~~



### elctron导出视频

~~~ts
//渲染进程
downloadVideo: (url: string | string[]) => {
  return ipcRenderer.invoke("download-video", url);
},
//主进程
ipcMain.handle("download-video", async (_, urls: string[] | string) => {
  const win = BrowserWindow.getFocusedWindow();

  const list = Array.isArray(urls) ? urls : [urls];

  const downloadDirectory =
    recordSavePath ||
    path.join(app.getPath("downloads"), "SugarTalk_Downloads");

  if (!fs.existsSync(downloadDirectory)) {
    fs.mkdirSync(downloadDirectory, { recursive: true });
  }

  const succeeded: string[] = [];

  const failed: { url: string; error: string }[] = [];

  for (const url of list) {
    try {
      const item = await download(win!, url, {
        directory: downloadDirectory,
        saveAs: false,
      });

      const savePath =
        typeof item?.getSavePath === "function" ? item.getSavePath() : "";

      succeeded.push(savePath || url);
    } catch (e) {
      failed.push({ url, error: (e as Error).message });
    }
  }

  return {
    success: failed.length === 0,
    directory: downloadDirectory,
    succeeded,
    failed,
  };
});
~~~

### 媒体/http链接/owa

electron mian

~~~ts
import { download } from "electron-dl"


await download(win, url, {
  directory: path.join(app.getPath("downloads"), "SugarTalk_Downloads"),
  saveAs: false,
})

event.sender.send("download-complete", url)
~~~



### word

[docxtemplater](https://docxtemplater.com/docs/tag-types/)+file-saver本地下载

```ts
//在项目本地资源存放.docx作为模版，模版内容通过docxtemplater语法编辑
{#list}{content}


{#list}

//
import {saveAs} from "file-saver";
import PizZip from "pizzip";
import Docxtemplater from "docxtemplater";

const _exportByWord = async (data: string[], type?: string) => {
  try {
    const response = await fetch('Doc.docx');

    const blob = await response.blob();

    const arrayBuffer = await blob.arrayBuffer();

    const zip = new PizZip(arrayBuffer);

    const doc = new Docxtemplater().loadZip(zip);

    doc.setOptions({
      nullGetter: function () {
        return "";
      }
    });

    doc.setData({
      list:data.map((item) => ({
        content: item,
      })),
    });

    doc.render();

    const out = doc.getZip().generate({
      type: "blob",
      mimeType:
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    });

    saveAs(out, `${state.title}-${type}.docx`);
  } catch (e){
    ElMessage({
      message: "導出失敗",
      type: "error",
    });
  }
};
```

- word 是一种压缩格式
- 通过fetch方式，读取模版文件二进制文件信息



### pdf

jsPdf + ttf

```ts
import { SourceHanSansK } from "../../iconfont/sourcehansansk";

const _exportByPdf = (data: string, type?: string) => {
  const doc = new jsPDF({
    orientation: "p",
    unit: "mm",
    format: "a4",
  });

  doc.addFileToVFS("sourcehansansk", SourceHanSansK);

  doc.addFont("sourcehansansk", "s", "normal");

  doc.setFont("s");

  const startX = 10,
    startY = 10,
    lineHeight = 10;

  const pageWidth = doc.internal.pageSize.getWidth() - startX * 2;

  const lines = doc.splitTextToSize(data, pageWidth, { wordwrap: true });

  const pageHeight = doc.internal.pageSize.getHeight();

  let nowY = startY;

  lines.forEach((line: string, index: number) => {
    if (nowY > pageHeight) {
      doc.addPage();

      nowY = startY;
    }

    doc.text(line, startX, nowY);

    nowY += lineHeight;
  });

  doc.save(`${state.title}-${type}.pdf`);
};
```

- SourceHanSansK为字体文件，在[](https://github.com/parallax/jsPDF/blob/master/fontconverter/fontconverter.html)转换器将ttf转为ES modules
- [思源雅黑](https://github.com/adobe-fonts/source-han-sans/blob/master/README-CN.md) [Google Fonts](https://fonts.google.com)
- [参考](https://www.cnblogs.com/ww01/p/11496213.html)



### video 元素



## 管理成员

ui

### 鉴权

计算属性+枚举，条件渲染显示按钮

#### 动态ref 列表渲染完成鼠标聚焦操作按钮条件渲染

~~~ts
// 列表渲染要key属性唯一（id），保证重新渲染

const optionUserRefs = ref<HTMLDivElement[]>([]);

optionUserRefs.value?.at(index)?.style &&
    (optionUserRefs.value.at(index)!.style.display = "flex");


:ref="
  (el) => {
    optionUserRefs[index] = el as HTMLDivElement;
  }
"
~~~



### livekit 自定义数据



## 预定会议和列表

ui

### 懒加载和动态ref

### electron窗口通信

MessageChannel模块

* 通信地址，因为electron每个窗口不同，所以要明确url，在生产环境中，则是域名或ip。使用*则发送给所有浏览器窗口

~~~ts
//preload
window.channelMessaging = {
  // 发送消息
  onSendMessage: (message) => {
    return ipcRenderer.invoke("channel-send-message", message);
  },
  //订阅消息
  onGiveMessage: () => {
    ipcRenderer.on("main-give-message", async (e) => {
      const origin = process.env.VITE_DEV_SERVER_URL + "";
      window.postMessage("main-give-message", "*", e.ports);
    });
  },
}
  
// mian
ipcMain.handle("channel-send-message", async (_, message: any) => {
  const targetWin = BrowserWindow.getFocusedWindow().getParentWindow();

  if (!targetWin) return;

  const { port1, port2 } = new MessageChannelMain();

  port2.postMessage(message);

  port2.close();

  targetWin.webContents.postMessage("main-give-message", null, [port1]);
});

ipcMain.handle("close-window-focus", async (_, path?: string) => {
  if (path) {
    const windowItem = windowManage.get(path);
    if (windowItem?.id) {
      BrowserWindow.fromId(windowItem.id).close();
    }
  } else {
    BrowserWindow.getFocusedWindow().close();
  }
});
~~~

~~~ts

//give
window.channelMessaging.onGiveMessage();

window.onmessage = (e) => {
  if (e.data === "main-give-message") {
    const [port] = e.ports;

    port.onmessage = (e) => {
      handleUpdateChannelMessage(e?.data);
    };
  }

  state.isModel = false;
};
~~~

webContents发送事件

- const wins = BrowserWindow.getAllWindows();发送给了所有窗口，也可以根据路径来决定发送给指定窗口

~~~ts
// preload
window.store = {
  dispatch: (id: string, hash: string) =>
    ipcRenderer.invoke("store-dispatch", id, hash),
  subscribe: (callback: (id: string, hash: string) => void) => {
    ipcRenderer.on("store-dispatch", (_, id: string, hash: string) =>
      callback(id, hash),
    );
  },
};

//main
ipcMain.handle("store-dispatch", (_, id: string, hash: string) => {
  const wins = BrowserWindow.getAllWindows();
  wins.forEach((win) => {
    win.webContents.send("store-dispatch", id, hash);
  });
});
~~~

~~~ts
// send
window.store.dispatch(type, m ?? "");
// subscribe
window.store.subscribe((id: StoreEventEnum, hash: any) => {})
~~~



### electron父子窗口

electron 属性





## 共享电脑声音



### mac

mac无法获取电脑默认扬声器音频



BlackHole2ch-0.6.0.pkg：虚拟音频设备

SwitchAudioSource：切换音频设备程序



### win

win使用desktopCapturer获取电脑扬声器音频（名称：扬声器）缺陷（会议中开麦声音也能听到）切换虚拟音频好像也一样有问题？



voicemeete‎rsetup.exe：虚拟设备，可执行文件（太大了不太ok）

nircm‎d.exe：切换音频程序，可执行文件

 VBCABLE_Dr‎iver_Pack45‎：虚拟设备，程序（文件夹



### ipc

~~~ts
// 定时器
class Timer {
  private static instance: Timer | null = null;

  private timerId: NodeJS.Timeout | null = null;

  public static getInstance(): Timer {
    if (!Timer.instance) {
      Timer.instance = new Timer();
    }

    return Timer.instance;
  }

  public start(callback: () => void, interval: number): void {
    this.timerId !== null && this.stop();

    this.timerId = setInterval(callback, interval);
  }

  public stop(): void {
    this.timerId && clearInterval(this.timerId);

    this.timerId = null;
  }
}

export default Timer.getInstance();
~~~

~~~ts
// perload
window.device = {
  // 脚本安装设备
  onInstallByPlatform: (platform: "mac" | "win" | "other") =>
    ipcRenderer.invoke("download-device", platform),
  // 切换音频设备
  onSwitchDefaultByWin: (
    target: "default" | "virtual",
    virtualDevice: string,
    defaultDevice: string,
  ) =>
    ipcRenderer.invoke(
      "switch-device-win",
      target,
      virtualDevice,
      defaultDevice,
    ),
};
~~~



~~~ts
// main
import { exec } from "child_process";
import { app, ipcMain } from "electron";
import log from "electron-log";
import path from "node:path";
import { default as deviceTimer, default as timer } from "./Timer";

let commandPath = "";

if (process.env.VITE_DEV_SERVER_URL) {
  commandPath = path.join(app.getAppPath(), "public", "SwitchAudioSource");
} else {
  commandPath = path.join(process.resourcesPath, "SwitchAudioSource");
}

ipcMain.handle(
  "download-device",
  async (_, platform: "mac" | "win" | "other") => {
    return new Promise((res, rej) => {
      if (!platform || platform === "other") return rej("Not Supported");

      const vbApp =
        platform === "mac"
          ? "BlackHole2ch-0.6.0.pkg"
          : "VBCABLE_Driver_Pack45/VBCABLE_Setup_x64.exe";

      let exePath: string = "";

      if (process.env.VITE_DEV_SERVER_URL) {
        exePath = path.join(app.getAppPath(), "Public", vbApp);
      } else {
        exePath = path.join(process.resourcesPath, vbApp);
      }

      const cmd =
        platform === "mac"
          ? `open ${exePath}`
          : `powershell -Command ${exePath}`;

      exec(cmd, (error) => {
        return rej(error);
      });

      res("");
    });
  },
);

ipcMain.handle(
  "switch-device-win",
  async (
    _,
    target: "default" | "virtual",
    virtualDevice: string,
    defaultDevice: string,
  ) => {
    deviceTimer.stop();

    return new Promise((res, rej) => {
      if (!virtualDevice && !defaultDevice) {
        return rej("No device selected");
      }

      try {
        let cmdPath: string = "";

        if (process.env.VITE_DEV_SERVER_URL) {
          cmdPath = path.join(app.getAppPath(), "Public", "nircmd.exe");
        } else {
          cmdPath = path.join(process.resourcesPath, "nircmd.exe");
        }

        const _switch = (deviceLabel: string) => {
          exec(`${cmdPath} setdefaultsounddevice "${deviceLabel}"`, (error) => {
            rej(error?.stderr);
          });
        };

        if (target === "virtual") {
          _switch(virtualDevice);

          deviceTimer.start(() => _switch(virtualDevice), 2000);
        } else if (target === "default") {
          _switch(defaultDevice);
        }

        res("");
      } catch (e) {
        deviceTimer.stop();

        rej(e);
      }
    });
  },
);
~~~



### electron打包设置

electron-bulder

~~~ts
files:
  [
    "public/BlackHole2ch-0.6.0.pkg",
    "SwitchAudioSource",
    "public/VBCABLE_Driver_Pack45",
    "nircmd.exe",
  ],
extraFiles:
  [
    {
      "from": "public/BlackHole2ch-0.6.0.pkg",
      to: "Resources/BlackHole2ch-0.6.0.pkg",
    },
    { "from": "public/SwitchAudioSource", to: "Resources/SwitchAudioSource" },
    {
      "from": "public/VBCABLE_Driver_Pack45",
      to: "Resources/VBCABLE_Driver_Pack45",
    },
    { "from": "public/nircmd.exe", to: "Resources/nircmd.exe" },
  ],
    
mac: {
  "signIgnore": ["public/BlackHole2ch-0.6.0.pkg", "SwitchAudioSource"],
  x64ArchFiles: "Contents/Resources/SwitchAudioSource",
}
~~~





### 实现思路

当不在共享时，切换回系统物理设备，当共享时，切换虚拟设备。想要获取到系统的声音，需要虚拟设备获取电脑媒体声音，在获取虚拟设备的音轨在推流上去，虚拟设备会手机系统音轨。共享时将虚拟设备音轨播放到当前选择的扬声器中，结束共享在讲输出音频设置为当前选择的物理扬声器，确保用户共享和结束共享不会突然听不到电脑播放声音



### bug

- 把应用声音也共享出去了，导致回音
- 切换时音质会变



## 过滤窗口

electron版本不同，过滤窗口效果不同，有些低版本不生效



## 共享窗口/桌面

electron获取窗口列表api实现，但无法获取到窗口的位置，导致无法在共享窗口上创建画布来实现在共享窗口上进行批注



## 互动批注

canvas + socket



## livekit-修改成员名称

livekit元数据修改权限，直接调用需要元数据修改接口方法



## 鼠标重影

可能是渲染问题，更新electron版本